# DesignPatterns

Каталог паттернов проектирования

1 Порождающие:

1.1 Abstract Factory - Абстрактная фабрика - паттерн уровня объекта, данный паттерн предоставляет интерфейс, для создания семеств взаимосвязанных или взаимозависимых объектов, не специфицируя их конктных классов (не указывая клиенту о наличии их конкретных классов). Назначение - порождение семеств взаимодействующих продуктов.

1.2 Builder - Строитель - паттерн уровня объекта, данный паттерн отделяет (пошаговое) конструирование сложного объекта (продукта) от его представления (посылка запроса - вызов метода - это единственный способ заставить объект выполнить какую-либо операцию, а выполнение операции - единственный способ изменить внутреннее состояние объекта, имея ввиду два этих ограничения говорят, что два этих состояния объекта инкапсулированы - скрыты - к ним нельзя получить непосредственный доступ, т.е. представление объекта закрыто от внешней программы. Поэтому ассоциируют внутреннее состояние с представлением) так, что в результате одного и того же процесса конструирования могут получиться разные представления (если мы подставим директору плотника, он сделает деревянный дом, если каменщика, то каменный дом). Назначение - пошаговое построение сложных продуктов.

1.3 Factory Method - Фабричный метод - паттерн уровня класса, является базовым для остальных порождающих паттернов. Его задача не только описать процесс получения объектов, но ещё описать взаимодействие между базовым классом и производным классом. Если мы не знаем, какой паттерн использовать для порождения продукта, то следует использовать Фабричный метод.

1.4 Prototype - Прототип - паттерн уровня объекта - паттерн уровня объекта, задаёт виды (классы), создаваемых объектов - клонов, с помощью экземпляра прототипа (оригинала) и создаёт новые объекты путём копирования (клонирования) этого прототипа. Назначение - клонирование объектов. Применяется редко, т.к. необходимо переходить на прототипно ориентированное мышление. В .Net нашёл реализацию в виде интерфейса ICloneable и смомощью метода MemberwiseClone базового класса Object.

1.5 Singleton - Синглтон - паттерн уровня объекта, данный паттерн гарантирует, что у класса есть (может быть) только определённое (переменное) число экземпляров (один экземпляр - частный случай). Назначение - гарантирует наличие только одного экземпляра класса. В .Net данный паттерн имеет два выражение, через проверку на инициализацию и через статический класс для случаев, когда требуется лишь один экземпляр без наследников.

2 Структурные:

2.1 Adapter - имеет две разновидности, уровня класса и уровня объекта, данный паттерн преобразует интерфейс одного класса (Adaptee) в интерфейс другого (Target), который ожидают клиенты, адаптер обеспечивает совместную работу классов с несовместимыми интерфейсами, которые без него была бы невозможна. Назначение - адаптирует несовместимые интерфейсы. Также существует два вида адаптера: сменный и двусторонний. Сменный адаптер, это такой адаптер PluggableAdapter, в который встроен механизм адаптации интерфейсов нескольких адаптируемых классов AdapteeA, AdapteeB и т.д. Двусторонние адаптеры способны обеспечить возможность использовать адаптер TwoWayAdapter там, где мог использоваться Adaptee.

2.2 Bridge - Бридж - паттерн уровня объекта, данный паттерн отделяет абстракцию от реализации так, чтобы и то и другое можно было изменять независимо друг от друга. Назначение - отделение абстракции от реализации.

2.3 Composite - Компоновщик - паттерн уровня объекта, данный паттерн компонует (собирает) объекты в древовидные структуры, для представления иерархии: часть - целое. Позволяет клиентам единообразно трактовать индивидуальные и составные объекты (для того, чтобы организовать рекурсиного обхода дерева и рекурсивной композиции (рекурсивного составления)). Деревья в данном контексте - это специальная структура данных, организованная по определённому принципу. Одна из целей паттерна компоновщик - избавить клиентов от обязанности знать работают ли они с листовым или составным уровнем, для достижения этой цели класс Component должен сделать как можно больше операций общими для классов Composite и Leaf. Обычно класс Component предоставляет для этих операций реализацию по умолчанию, а подклассы Composite и Leaf замещают их. Однако иногда эта цель вступает в конфликт с принципом проектирования иерархии классов, согласно которому класс должен определять (содержать), только логичные для всех его подклассов и его самого, операции. Класс Component поддерживает много операций не имеющих смысла для класса Leaf. Как же тогда предоставить для них реализацию по умолчанию? Иногда проявив изобретательность удаётся перенести в класс Component операцию, которая на первый взгляд имеет смысл только для составных объектов. Например, интерфейс для доступа к потомкам является фундаментальной частью класса Composite, но вовсе не обязательно для класса Leaf. Ответ: следует рассматривать Leaf, как ветку, у которой никогда не бывает потомков. И мы можем определить в классе Component операцию доступа к потомкам, как никогда не возвращающего потомков. Тогда подклассы Leaf могут использовать эту реализацию по умолчанию, а в подклассах Composite она будет переопределена, чтобы возвращать потомков. Объявление операции, для управления потомками: хотя в классе Composite реализованы операции Add и Remove для добавления и удаления потомков, для паттерна Composite важно в каких классах эти операции объявлены, надо ли объявлять их в классе Component и тем самым делать их доступными в Leaf или его следует объявить только в классе Composite и его подклассах. Решая этот вопрос мы должны выбирать между безопасностью и прозрачностью. Если определить интерфейс для управления потомками в корне иерархии классов, то мы добиваемся прозрачности, т.к. все компоненты удаётся трактовать единообразно. Однако расплачиваться приходится безопасностью, поскольку клиент мог выполнить бессмысленное действие, например добавить или удалить объект из листочка Leaf. Если управление потомками сделать частью класса Composite, то безопасность удаётся обеспечить, ведь любая попытка добавить или удалить объекты из листочков Leaf приведёт к ошибке, но тогда мы утрачиваем прозрачность, т.к. у листовых и составных объектов оказываются различные интерфейсы. В паттерне Composite придаётся особое значение прозрачности, а не безопасности. Назначение - построение "деревьев".
